# آموزش Async در پایتون

## پیش نیازها: پایتون 3.5 به بعد

---
### جلسه 2
کد زیر رو در نظر بگیرید:
```python
x = 10
while True:
  x += 1
  print(x)
```

### عکس قبل از اجرا
![عکس قبل از اجرا](images/cpu-01.png)

### عکس هنگام اجرا
![عکس هنگام اجرا](images/cpu-02.png)

نکته قابل توجه این است که بعد از اجرا این حلقه بی نهایت, سیستم از تمام ظرفیت پردازشی خود استفاده نکرده است.
از 14 هسته CPU تنها 1 هسته درگیر پردازش میشود.

هنگامی که از برنامه نویسی Async استفاده میکنیم, سرعت به اندازه تعداد هسته های CPU ما افزایش پیدا نمیکند! بلکه بخش هایی از فرآیند عملیات ها که میتوانند موازی انجام شوند, موازی با فرآیند اصلی انجام میشوند.

برای مثال هنگامی که در یک سایت فروشگاهی شما صفحه محصولی را باز میکند و آن را به سبد خرید خود اضافه میکنید و سپس به درگاه پرداخت میروید تا پرداخت کنید؛ در این فرآیند هیچ بخشی نمیتواند موازی انجام شود، بلکه باید به ترتیب انجام شود.

ولی کارهایی مانند ارسال ایمیل یا پیامک تایید پرداخت و... را میتوانید موازی با فرآیند ثبت سفارش انجام دهید.

---
### جلسه 3
### Sync VS Async
![sync](images/sync.png)
![Async](images/Async.png)

درحالت sync هنگامی که یک تسک درحال اجرا است، اگر تسک دیگری وارد بشود، باید منتظر بماند تا فرآیند تست قبلی انجام شود تا نوبت به انجام آن برسد.

اما در برنامه نویسی Async هنگامی که یک تسک شروع میشود در فضای ThreadPool رها میشود تا انجام شود. درهمین هنگام سراغ تسک بعدی میرود.

---
### جلسه 4
### GIL (Global Interpreter Lock)

برای درک عمیق راجب GIL میتوانید از [این مقاله](https://realpython.com/python-gil/) استفاده کنید.


### نحوه کار async در یک Thread پایتون !

![Async](images/async-in-python.png)

توجه کنید که این فرآیند برای یک Thread در پایتون انجام میشود !

نکته مهم در این موضوع این است که هرکدام از هسته های CPU میتواند خود به این صورت کار کنند.

---
### جلسه 5
با استفاده از Generator ها در زبان پایتون میتوانیم منتظر اتمام فرآیند یک تابع نمانیم و در هر مرحله نتیجه را yeald کنیم.

به این کد توجه کنید:

```python
def fib():
  # 0, 1, 1, 2, 3, 5, ...

  current, nxt = 0, 1
  while True:
    current, nxt = nxt, current + nxt
    yield current

result = fib()

for item in result:
  if item > 1000:
    break
  
  print(item, end=", ")
```

خروجی این کد به صورت زیر است:

```bash
1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 
```

در پایتون، Generatorها توابعی هستند که بجای بازگرداندن یک مقدار با استفاده از return، میتوانند در هر فراخوانی خروجی همان مرحله را محاسبه و بازگرداندن.

نکته مهم در استفاده از Generatorها این است که Generatorها مقدار مرحله قبل را در خود ذخیره میکنند.

برای استفاده از Generatorها میتوانیم به دو صورت عمل کنیم:

1- با استفاده از دستور `()next`
```python
result = fib()

print(next(result))
```

```bash
> 1
```

2- فراخوانی در یک حلقه
```python
result = fib()

for item in result:
    print(item, end=", ")
```

```bash
> 1, 1, 2, 3, ...
```

#### دلیل اهمیت Generatorها در مبحث Async:
یکی از خصوصیات اصلی که پکیج AsyncIo در پس زمینه از آن استفاده میکند، مبحث Generatorها است. به همین دلیل درک ساختار Generatorها از اهمیت بالایی برخوردار است.

---
### جلسه 7

در اینجا یک تسک را به صورت sync و async پیاده سازی کرده ایم.
در این مثال سعی کرده ایم فرآیند اسکرپ کردن دیتا از سایت را شبیه سازی کنیم.

[مشاهده کد sync](./codes/sync_scraper_task.py)

[مشاهده کد async](./codes/async_scraper_task.py)

مدت زمان انجام این تسک به صورت sync برابر با 24 ثانیه بود اما انجام این تسک به صورت async در 13 ثانیه انجام شده است.

این اختلاف به این دلیل است که در روش sync باید ابتدا همه url ها اسکرپ بشود و در یک لیست ذخیره شود؛ سپس فرآیند پردازش آن انجام شود.

اما در روش async همزمان با اسکرپ کردن یک صفحه، پردازش آن نیز انجام میشود.

نکات قایل توجه در کد async:


1- در `print` یک `flush=True` قرارداده شده تا به سرعت پرینت شود.

2- با استفاده از `data = asyncio.Queue()` یک صف ایجاد میکنیم.

3- به صورت زیر توابع رو به تسک تبدیل میکنیم:
```python
task_1 = asyncio.create_task(scrap_data(20, data))
task_2 = asyncio.create_task(process_data(20, data))
```
توجه: برای تبدیل تابع به تسک، باید تابع async باشد. (در ابتدای آن async بگذارید)

4- با استفاده از `asyncio.gather()` تسک هارو اجرا میکنیم.

```python
await asyncio.gather(task_1, task_2)
```


5- برای کار با `asyncio.Queue()`ها از `put()` و `get()` استفاده میکنیم.

6- برای ایجاد `sleep` از `asyncio.sleep()` استفاده میکنیم.

7- برای اجرای این فایل به صورت async به صورت زیر عمل میکنیم:
```python
if __name__ == "__main__":
    asyncio.run(main())
```

8- از پایتون `3.10` به بعد، استفاده مستقیم از `get_event_loop()` توصیه نمی‌شود و ممکن است `DeprecationWarning` دریافت کنید. بهتر است از `asyncio.run(say_hello())` استفاده کنیم.

#### تفاوت `time.sleep()` و `asyncio.sleep()`
همانطور که گفتیم، در پایتون یک `Thread` وجود دارد که وظیفه انجام کدهارو برعهده دارد. هنگامی که کد به صورت sync نوشته میشود، این کد به صورت خط به خط اجرا میشود. هنگامی که کد به صورت async نوشته شود، در بخش هایی از کد (مانند اتصال به دیتابیس و یا خواندن فایل و...) این  `Thread` انجام این تابع رو رها میکنه و به سراغ تسک بعدی میرود. اگر در کد async از `time.sleep()` استفاده کنیم، هنگام مواجه شدن با آن، `Thread` منتظر میماند. اصطلاحا قفل میشود. بنابراین برای اینکه این صبرکردن در پس زمینه انجام شود، باید از `asyncio.sleep()` استفاده کنیم.

#### استفاده از await
در برنامه نویسی async نیاز داریم تا در بخش هایی از برنامه منتظر بمانیم تا نتیجه تابعی بازگردانده شود. اگر به صورت sync بنویسم، برنامه متوقف میشود تا این پردازش انجام شود. اگر به صورت async بنویسیم، باید از `await` استفاده کنیم تا برنامه منتظر انجام این تابع بماند **اما در بک گراند**! بنابراین در این حین `Thread` به انجام سایر تسک ها میپردازد.

فراموش نشود که استفاده از `await` تنها در توابع async قایل استفاده است.

---
### جلسه 8

با استفاده از پکیج `uvloop` میتوانیم سرعت اجرا کدهارو حدود 2 تا 4 برابر افزایش بدهیم. این پکیج با استفاده از زبان C پیاده سازی شده است. به صورت زیر میتوانیم از این پکیج استفاده کنیم.

```python
import asyncio
import uvloop

asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
```

البته این روش روی ویندوز اجرا نمیشود.

---
### جلسه 9

بجای استفاده از پکیج `requests` باید از `aiohttp` استفاده کنیم. این پکیج به صورت async پیاده سازی شده است.
برای استفاده از این پکیج باید به صورت context manager استفاده کنیم.

نمونه کد استفاده از `aiohttp`:
```python
import aiohttp

async def scrap_url():
	async with aiohttp.ClientSession() as session:
		async with session.get("url") as response:
			return await response.text()
```
[کد مربوط به اسکرپ سایت تاپ لرن به صورت async](./codes/async_scrap.py)

---
### جلسه 10
معرفی چند پکیج محبوب استفاده از async:

1- aiofiles   
2- umongo   
3- asyncpg  
4- asyncio-redis


### استفاده از `asyncio` یا `threads` ?
اگر برای کاری که میخواهیم انجام بدهیم، پکیجی وجود دارد که به صورت async پیاده سازی شده باشد، حتما از asyncio استفاده کنیم.
برای مثال بجای استفاده از پکیج requests که به صورت sync است، میتوانیم از پکیج aiohttp استفاده کنیم که به صورت async است.

اما اگر پکیجی که میخواهیم از آن استفاده کنیم، جایگزین async ندارد، باید از `threads` استفاده کنیم.


### نحوه استفاده از `Threads`
![Async](images/threads.png)

---
### جلسه 11

نمونه کد پیاده سازی به روش `Threading`:
```python
import threading
import time

def main():
    t = threading.Thread(target=greeter, args=("Mohammad", ))
    t.start()
    print("Task Done !")
    

def greeter(name: str, count: int = 10):
    for i in range(count):
        print(f"{i + 1} - Hello {name}")
        time.sleep(1)
        
main()
```

در این کد Thread اصلی انجام میشود و در پس زمینه به صورت موازی تسک اجرا میشود.

اگر بخواهیم نخ اصلی منتظر تمام شدن نخ های دیگر بماند میتوانیم از دستور `t.join()` استفاده کنیم.

اگر بخواهیم تسک در بک گراند کاری را انجام بدهد، باید درون `threading.Thread()` از `daemon=True` استفاده کنیم.

